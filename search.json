[{"title":"ST表","url":"/2025/08/22/ST%E7%AE%97%E6%B3%95/","content":"在解决 RMQ 问题（区间最值问题）时，ST 表是一个非常重要的方法。RMQ 问题要求区间 $\\left[ l,r \\right]$ 的最大值，会有多次询问。我们知道一个长度为 $n$ 的序列有 $n^{2}$ 个区间，如果老老实实的求出每个区间的最值，那复杂度为 $O(n^{2})$ ，显然不是很优。而横空出世的ST算法可以以 $O(n\\log n)$ 的复杂度将序列进行预处理，然后满足 $O(1)$ 查询。\nST算法运用了倍增的思想，其大致思路如下：用数组 $f[i][j]$ 来表示序列 $a$ 区间 $\\left[ i,i+2^{j}-1 \\right]$ 的最大值。在预处理出法 $f[i][j]$ 数组时，用递推的方法。首先可以明确递推的边界是 $f[i][0]&#x3D;a[i]$ 。递推的公式为\n$$f[i][j]&#x3D;\\max(f[i][j-1],f[i+2^{j-1}][j-1])$$\n递推的思想是讲要求的区间进行二分，最大值就是两部分最大值的最大值。\nint a[M],f[M][22];void setf()&#123;\tfor(int i=1;i&lt;=n;i++) f[i][0]=a[i];\tint t=log(n)/log(2);\tfor(int i=1;i&lt;=t;i++) for(int j=1;j&lt;=n;j++) \tf[i][j]=max(f[j][i-1],f[j+(1&lt;&lt;(i-1))][i-1]);&#125;\n\n查询的时候就找到最大的 $k$ 满足 $2^{k}&lt; r-l+1\\leq 2^{k+1}$ ，也就是满足长度不超过区间长度的 $k$ ，则区间 $\\left[ l,r \\right]$ 的最大值为 $max(f[l][k],f[r-2^{k}+1][k])$ ，\nint st(int l,int r)&#123;\tint k=log(r-l+1)/log(2);\treturn max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;\n\n整体代码如下\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;const int M=1e5+50;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;  int logn[M],f[M][22];int n,m,a[M];  void setl()&#123;    logn[1]=0;    REP(i,2,n) logn[i]=logn[i&gt;&gt;1]+1;&#125;  void setf()&#123;    REP(i,1,n) f[i][0]=a[i];    int t=logn[n];    REP(i,1,t)&#123;        REP(j,1,n-(1&lt;&lt;i)+1) f[j][i]=max(f[j][i-1],f[j+(1&lt;&lt;(i-1))][i-1]);    &#125;&#125;  int st(int l,int r)&#123;    int k=logn[r-l+1];    return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123;    n=rd(), m=rd();    REP(i,1,n) a[i]=rd();    setl(),setf();    while(m--)&#123;        int l=rd(),r=rd();        printf(&quot;%d\\n&quot;,st(l,r));    &#125;    return 0;&#125;\n","categories":["算法"]},{"title":"逆序数","url":"/2025/08/22/%E9%80%86%E5%BA%8F%E6%95%B0/","content":"归并排序求逆序数记录一下求逆序数的方法：\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;const int M=5e5+50;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;  int a[M],b[M];  ll merge_sort(int l, int r)&#123;    if(l&gt;=r) return 0;    int mid=(l+r)&gt;&gt;1;    ll ans=merge_sort(l,mid)+merge_sort(mid+1,r);    int i=l, j=mid+1, k=0;    while(i&lt;=mid &amp;&amp; j&lt;=r)&#123;        if(a[i]&lt;=a[j]) b[k++]=a[i++];        else&#123;            b[k++]=a[j++];            ans+=mid-i+1;        &#125;    &#125;    while(i&lt;=mid) b[k++]=a[i++];    while(j&lt;=r) b[k++]=a[j++];    for(int i1=l,i2=0;i1&lt;=r;i1++,i2++) a[i1]=b[i2];    return ans;&#125;  int main()&#123;    int n;    while(n=rd())&#123;        REP(i,1,n) a[i]=rd();        cout&lt;&lt;merge_sort(1,n)&lt;&lt;endl;        REP(i,1,n) cout&lt;&lt;a[i];    &#125;    return 0;&#125;\n","categories":["算法"]},{"title":"genius ACM","url":"/2025/08/22/genius%20ACM/","content":"题目： genius ACM\n贪心+倍增+归并\n109. 天才ACM - AcWing题库\n题解：\n让我红温三天的题目，必须写个题解记录一下。\n这题的思路不难。首先题目中给出了校验值的定义：\n从集合 $S$ 中取出 $M$ 对数(即 $2\\times M$ 个数，不能重复使用集合中的数，如果 $S$ 中的整数不够 $M$ 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 $S$ 的“校验值”。\n我们要把序列 $A$ 分成若干段，使得每一段的“校验值”都不超过 $T$ ，然后求最少得段数。\n可以想到，因为每一段都是连续的，所以我们只要让每一段包含的数尽量多就能使得段数最少。\n为了使复杂度符合要求，使用倍增的做法：\n初始令 $L&#x3D;R&#x3D;1$ ，$p&#x3D;1$ 。\n当 $R\\leq N$ 时，我们进行如下操作：\n\n如果区间 $\\left[L,R+p  \\right]$ 的校验值小于 $T$ ，那么我们就将 $R+&#x3D;p,;p*&#x3D;2$ \n如果大于 $T$ ，我们就将 $p&#x2F;&#x3D;2$ \n如果 $p&#x3D;0$ 我们就找到一段区间 $\\left[L,R  \\right]$ 满足包含的数最多。我们将总段数加1，然后令 $L+1,R+1$ ，找到下一个区间的右端点\n\n下面的是大概的代码\nint ans=0;int R=1,L=1;while(R&lt;=N)&#123;\tint p=1;\twhile(p)&#123;\t\tif(R+p&gt;=N)&#123;p&gt;&gt;=1; continue;&#125;  //防止越界\t\tif(cal(L,R)&lt;T)&#123;R+=p; p*=2;&#125; //cal函数表示计算校验值\t\telse p&gt;&gt;=1; \t&#125;\tL=++R;   //注意不要写成 R++ ！！！\tans++;&#125;\n\n整体的思路就是上面，但是我们还没有解决如何求校验值的问题。\n其实也简单，如果我们要求区间 $\\left[L,R  \\right]$ 的校验值，我们只需要将该区间排序，然后根据校验值的定义计算即可，但是这样做复杂度容易超，因为我们每次计算校验值都需要重新排序，这时候我们就要用归并排序的方法简化复杂度 。\n我们可以用一个数组 $u$ 来存排序后的数组 $a$ 。如果我们已经将区间 $\\left[L,R  \\right]$ 排序完成，我们要计算区间 $\\left[L,R +p\\right]$ 的校验值，我们只需要将 $\\left[R+1,R+p  \\right]$ 进行排序，然后再用归并排序的方法将 $\\left[L,R  \\right]$ 和 $\\left[R+1,R+p  \\right]$ 合并就得到了有序的区间 $\\left[L,R +p\\right]$ 。\n代码如下：\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;int K,N,M;ll T;vector&lt;int&gt; a,u;//计算校验值ll cal(vector&lt;int&gt; &amp;v,int l,int r)&#123;    ll res=0;    int len=min(M,(r-l+1)/2);    REP(i,0,len-1) res+=(ll)(v[r-i]-v[i+l])*(v[r-i]-v[i+l]);    return res;&#125;//排序+判断校验值是否小于Tbool mer(vector&lt;int&gt; &amp;v,int l,int mid,int r)&#123;    int i=l,j=mid+1;    REP(k,j,r) u[k]=a[k];  //将新增片段拷贝给u，防止前面失败后的u污染    sort(u.begin()+mid+1,u.begin()+r+1);     vector&lt;int&gt; tmp;    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;        if(u[i]&lt;=u[j]) tmp.push_back(u[i++]);        else tmp.push_back(u[j++]);    &#125;    while(i&lt;=mid) tmp.push_back(u[i++]);    while(j&lt;=r) tmp.push_back(u[j++]);    if(cal(tmp,0,tmp.size()-1)&gt;T) return 0;    for(int i1=l,i2=0;i1&lt;=r;i1++,i2++) u[i1]=tmp[i2]; //只有满足条件才拷贝    return 1;&#125;void sol()&#123;    N=rd(),M=rd(),T=rd();    int ans=0;    a.resize(N+1);    REP(i,1,N) a[i]=rd();    u.assign(a.begin(),a.end());    int L=1,R=1;    while(R&lt;=N)&#123;        int p=1;        while(p)&#123;            if(R+p&gt;N)&#123;p&gt;&gt;=1; continue;&#125;            if(mer(u,L,R,R+p)) &#123;R+=p; p*=2;&#125;            else p&gt;&gt;=1;        &#125;        ans++;        L=++R;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    K=rd();    while(K--) sol();    return 0;&#125;\n","categories":["算法"]}]