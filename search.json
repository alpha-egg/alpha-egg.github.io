[{"title":"ST表","url":"/2025/08/22/ST%E7%AE%97%E6%B3%95/","content":"在解决 RMQ 问题（区间最值问题）时，ST 表是一个非常重要的方法。RMQ 问题要求区间 $\\left[ l,r \\right]$ 的最大值，会有多次询问。我们知道一个长度为 $n$ 的序列有 $n^{2}$ 个区间，如果老老实实的求出每个区间的最值，那复杂度为 $O(n^{2})$ ，显然不是很优。而横空出世的ST算法可以以 $O(n\\log n)$ 的复杂度将序列进行预处理，然后满足 $O(1)$ 查询。\nST算法运用了倍增的思想，其大致思路如下：用数组 $f[i][j]$ 来表示序列 $a$ 区间 $\\left[ i,i+2^{j}-1 \\right]$ 的最大值。在预处理出法 $f[i][j]$ 数组时，用递推的方法。首先可以明确递推的边界是 $f[i][0]&#x3D;a[i]$ 。递推的公式为\n$$f[i][j]&#x3D;\\max(f[i][j-1],f[i+2^{j-1}][j-1])$$\n递推的思想是讲要求的区间进行二分，最大值就是两部分最大值的最大值。\nint a[M],f[M][22];void setf()&#123;\tfor(int i=1;i&lt;=n;i++) f[i][0]=a[i];\tint t=log(n)/log(2);\tfor(int i=1;i&lt;=t;i++) for(int j=1;j&lt;=n;j++) \tf[i][j]=max(f[j][i-1],f[j+(1&lt;&lt;(i-1))][i-1]);&#125;\n\n查询的时候就找到最大的 $k$ 满足 $2^{k}&lt; r-l+1\\leq 2^{k+1}$ ，也就是满足长度不超过区间长度的 $k$ ，则区间 $\\left[ l,r \\right]$ 的最大值为 $max(f[l][k],f[r-2^{k}+1][k])$ ，\nint st(int l,int r)&#123;\tint k=log(r-l+1)/log(2);\treturn max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;\n\n整体代码如下\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;const int M=1e5+50;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;  int logn[M],f[M][22];int n,m,a[M];  void setl()&#123;    logn[1]=0;    REP(i,2,n) logn[i]=logn[i&gt;&gt;1]+1;&#125;  void setf()&#123;    REP(i,1,n) f[i][0]=a[i];    int t=logn[n];    REP(i,1,t)&#123;        REP(j,1,n-(1&lt;&lt;i)+1) f[j][i]=max(f[j][i-1],f[j+(1&lt;&lt;(i-1))][i-1]);    &#125;&#125;  int st(int l,int r)&#123;    int k=logn[r-l+1];    return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123;    n=rd(), m=rd();    REP(i,1,n) a[i]=rd();    setl(),setf();    while(m--)&#123;        int l=rd(),r=rd();        printf(&quot;%d\\n&quot;,st(l,r));    &#125;    return 0;&#125;\n","categories":["算法"]},{"title":"逆序数","url":"/2025/08/22/%E9%80%86%E5%BA%8F%E6%95%B0/","content":"归并排序求逆序数记录一下求逆序数的方法：\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;const int M=5e5+50;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;  int a[M],b[M];  ll merge_sort(int l, int r)&#123;    if(l&gt;=r) return 0;    int mid=(l+r)&gt;&gt;1;    ll ans=merge_sort(l,mid)+merge_sort(mid+1,r);    int i=l, j=mid+1, k=0;    while(i&lt;=mid &amp;&amp; j&lt;=r)&#123;        if(a[i]&lt;=a[j]) b[k++]=a[i++];        else&#123;            b[k++]=a[j++];            ans+=mid-i+1;        &#125;    &#125;    while(i&lt;=mid) b[k++]=a[i++];    while(j&lt;=r) b[k++]=a[j++];    for(int i1=l,i2=0;i1&lt;=r;i1++,i2++) a[i1]=b[i2];    return ans;&#125;  int main()&#123;    int n;    while(n=rd())&#123;        REP(i,1,n) a[i]=rd();        cout&lt;&lt;merge_sort(1,n)&lt;&lt;endl;        REP(i,1,n) cout&lt;&lt;a[i];    &#125;    return 0;&#125;\n","categories":["算法"]},{"title":"genius ACM","url":"/2025/08/22/genius%20ACM/","content":"题目： genius ACM\n贪心+倍增+归并\n109. 天才ACM - AcWing题库\n题解让我红温三天的题目，必须写个题解记录一下。\n这题的思路不难。首先题目中给出了校验值的定义：\n从集合 $S$ 中取出 $M$ 对数(即 $2\\times M$ 个数，不能重复使用集合中的数，如果 $S$ 中的整数不够 $M$ 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 $S$ 的“校验值”。\n我们要把序列 $A$ 分成若干段，使得每一段的“校验值”都不超过 $T$ ，然后求最少得段数。\n可以想到，因为每一段都是连续的，所以我们只要让每一段包含的数尽量多就能使得段数最少。\n为了使复杂度符合要求，使用倍增的做法：\n初始令 $L&#x3D;R&#x3D;1$ ，$p&#x3D;1$ 。\n当 $R\\leq N$ 时，我们进行如下操作：\n\n如果区间 $\\left[L,R+p  \\right]$ 的校验值小于 $T$ ，那么我们就将 $R+&#x3D;p,;p*&#x3D;2$ \n如果大于 $T$ ，我们就将 $p&#x2F;&#x3D;2$ \n如果 $p&#x3D;0$ 我们就找到一段区间 $\\left[L,R  \\right]$ 满足包含的数最多。我们将总段数加1，然后令 $L+1,R+1$ ，找到下一个区间的右端点\n\n下面的是大概的代码\nint ans=0;int R=1,L=1;while(R&lt;=N)&#123;\tint p=1;\twhile(p)&#123;\t\tif(R+p&gt;=N)&#123;p&gt;&gt;=1; continue;&#125;  //防止越界\t\tif(cal(L,R)&lt;T)&#123;R+=p; p*=2;&#125; //cal函数表示计算校验值\t\telse p&gt;&gt;=1; \t&#125;\tL=++R;   //注意不要写成 R++ ！！！\tans++;&#125;\n\n整体的思路就是上面，但是我们还没有解决如何求校验值的问题。\n其实也简单，如果我们要求区间 $\\left[L,R  \\right]$ 的校验值，我们只需要将该区间排序，然后根据校验值的定义计算即可，但是这样做复杂度容易超，因为我们每次计算校验值都需要重新排序，这时候我们就要用归并排序的方法简化复杂度 。\n我们可以用一个数组 $u$ 来存排序后的数组 $a$ 。如果我们已经将区间 $\\left[L,R  \\right]$ 排序完成，我们要计算区间 $\\left[L,R +p\\right]$ 的校验值，我们只需要将 $\\left[R+1,R+p  \\right]$ 进行排序，然后再用归并排序的方法将 $\\left[L,R  \\right]$ 和 $\\left[R+1,R+p  \\right]$ 合并就得到了有序的区间 $\\left[L,R +p\\right]$ 。\n代码如下：\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)using namespace std;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;int K,N,M;ll T;vector&lt;int&gt; a,u;//计算校验值ll cal(vector&lt;int&gt; &amp;v,int l,int r)&#123;    ll res=0;    int len=min(M,(r-l+1)/2);    REP(i,0,len-1) res+=(ll)(v[r-i]-v[i+l])*(v[r-i]-v[i+l]);    return res;&#125;//排序+判断校验值是否小于Tbool mer(vector&lt;int&gt; &amp;v,int l,int mid,int r)&#123;    int i=l,j=mid+1;    REP(k,j,r) u[k]=a[k];  //将新增片段拷贝给u，防止前面失败后的u污染    sort(u.begin()+mid+1,u.begin()+r+1);     vector&lt;int&gt; tmp;    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;        if(u[i]&lt;=u[j]) tmp.push_back(u[i++]);        else tmp.push_back(u[j++]);    &#125;    while(i&lt;=mid) tmp.push_back(u[i++]);    while(j&lt;=r) tmp.push_back(u[j++]);    if(cal(tmp,0,tmp.size()-1)&gt;T) return 0;    for(int i1=l,i2=0;i1&lt;=r;i1++,i2++) u[i1]=tmp[i2]; //只有满足条件才拷贝    return 1;&#125;void sol()&#123;    N=rd(),M=rd(),T=rd();    int ans=0;    a.resize(N+1);    REP(i,1,N) a[i]=rd();    u.assign(a.begin(),a.end());    int L=1,R=1;    while(R&lt;=N)&#123;        int p=1;        while(p)&#123;            if(R+p&gt;N)&#123;p&gt;&gt;=1; continue;&#125;            if(mer(u,L,R,R+p)) &#123;R+=p; p*=2;&#125;            else p&gt;&gt;=1;        &#125;        ans++;        L=++R;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    K=rd();    while(K--) sol();    return 0;&#125;\n","categories":["算法"]},{"title":"火车进出站问题","url":"/2025/08/22/%E7%81%AB%E8%BD%A6%E8%BF%9B%E5%87%BA%E7%AB%99%E9%97%AE%E9%A2%98/","content":"题目： 火车进出站问题\n卡特兰数+高精度\n130. 火车进出栈问题 - AcWing题库\n题解有 $1 \\sim n$ 共 n 个数，可以进行进栈和出栈两个操作，问总共有多少种出栈顺序。\n$$1\\leq n\\leq 60000$$\n关于这道题，我认为难点有二：\n\n如何解决数学问题（如何找到题目的公式）\n如何解决高精度问题\n\n数学部分首先来解决数学问题，其实如果 n 的数据范围没有这么大的话，这题其实很简单。\n因为我们并不在乎出栈的具体方案，只在意出栈方案的总数。我们可以用递推的思路来解决这道题。递推的本质是把一个问题分为几个子问题进行解决。\n当数据总量为 N 时，考虑 1 在出栈序列中的位置。如果 1 是第 k 个出栈的，那么出栈的过程可以列为：\n\n1 进栈\n$2 \\sim k$ 以某种方案进出栈\n1 出栈\n$k+1 \\sim N$ 以某种方式进出栈\n\n也就是说，N个数的进出栈问题，被 1 的位置划分成了 $k-1$ 和 $N-k$ 个数的进出栈问题，递推公式为\n$$S_{N}&#x3D;\\sum_{k&#x3D;1}^{i} S_{k-1}*S_{N-k}$$于是我们就可以用递推的方法解决，复杂度为 $O(n^{2})$ .\n这题其实是卡特兰数的应用，介绍卡特兰数：\n\n卡特兰数的递推公式就是 $C_{n}&#x3D;\\sum_{k&#x3D;1}^{n} C_{k-1}*C_{n-k}$\n卡特兰数的通项公式为 $C_{n}&#x3D;\\dfrac{C_{2n}^{n}}{n+1}$\n\n我们已经推导了递推公式，现在来推导通项公式：\n我们可以把数字进出栈的过程看做一串 01 序列，1表示进栈，0表示出栈。一个 01 序列唯一对应一个出栈方案。显然 01 序列的长度为 $2n$ ，0 和 1 都有 n 个。\n01 序列的排列总数为 $C_{2n}^{n}$ ，可以理解为从 2n 个空位中选取 n 个位置填 0。但是并不是所有的排列都满足条件，一个合理的 01 序列必须满足：所有前缀 1 的数量大于 0。\n假设 01 序列从 2m+1 项开始不满足条件，也就是说前 2m+1 项有 m个 1 和 m+1 个 0。后面的项中有 $n-m-1$ 个 0 ，$n-m$ 个 1，我们把后面的项 0 和 1 互相映射，得到 $n-m-1$ 个 1 ，$n-m$ 个 0，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。\n反过来，任何一个由n+1个0和n-1个1组成的序列，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。\n故不符合要求的数有 $C_{2n}^{n-1}$ 个，所以有 $C_{2n}^{n}-C_{2n}^{n-1}$ 个数满足，即 $\\dfrac{C_{2n}^{n}}{n+1}$.\n高精度我们已经解决了数学问题，现在对于任意的 n ，我们只要输出 $\\dfrac{C_{2n}^{n}}{n+1}$ 就好了。也就是 $\\dfrac{2n!}{(n!)(n!)(n+1)}$ 。\n当 n 的可以取到 60000 时，显然会爆精度，我们必须用数组来存答案。\n为了降低时间复杂度，我们把阶乘分解为质因数的幂次进行求解，该过程在筛选质数的同时进行。\n代码如下：\n#include&lt;bits/stdc++.h&gt;#define REP(i,a,b) for(int i=(a); i&lt;=(b); i++)#define PER(i,a,b) for(int i=(a); i&gt;=(b); i--)#define PII std::pair&lt;int,int&gt;using namespace std;const int M=6e4+50, B=1e9, bb=9;typedef long long ll;inline ll rd()&#123;    ll x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while(isdigit(c))&#123;x=10*x+c-&#x27;0&#x27;; c=getchar();&#125; return x*f;&#125;int n;bool notp[M*2];int a[M];ll res[6000];vector&lt;int&gt; pri;void init()&#123;    notp[1]=1;    REP(i,2,2*n)&#123;        if(!notp[i])&#123;            pri.push_back(i);            int cnt=pri.size()-1;            for(int j=2*n/i;j;j/=i) a[cnt]+=j; //加上2n!的幂次            for(int j=n/i;j;j/=i) a[cnt]-=j*2; //减去 (n!)(n!) 的幂次            for(int j=n+1;j%i==0;j/=i) a[cnt]--; //n+1        &#125;        for(auto p:pri)&#123;            if(p*i&gt;2*n) break;            notp[p*i]=1;            if(p%i==0) break;        &#125;    &#125;&#125;ll qpow(ll a,ll x)&#123;    ll res=1;    if(a==1||x==0) return res;    while(x)&#123;        if(x&amp;1) res*=a;        a*=a;        x&gt;&gt;=1;    &#125;    return res;&#125;// 高精度乘法void mul(ll x)&#123;     ll t=0;    REP(i,1,res[0])&#123;        res[i]=res[i]*x+t;        t=res[i]/B;//进位        res[i]%=B; //res[i]一位存1e9以内的数字，相比于只存一位输出更快    &#125;    while(t) res[++res[0]]+=t%B, t/=B; //增加位数&#125;//倒序输出+补0void print(int x,int i=bb)&#123;     if(!i) return;    print(x/10,i-1);    putchar((x%10)+&#x27;0&#x27;); // 输出x的末位数字，因为putchar输出的是ASSIC码对应的字符&#125;int main()&#123;    cin&gt;&gt;n;    init();    int len=pri.size()-1;    res[0]=1, res[1]=1; //res[0]存长度，res[1] 初始化为1    REP(i,0,len) if(a[i]) mul(qpow(pri[i],a[i]));    printf(&quot;%lld&quot;,res[res[0]]); //第一位不需要补0    PER(i,res[0]-1,1) print(res[i]);    return 0;&#125;\n","categories":["算法"]}]